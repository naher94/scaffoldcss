// Foundation for Sites
// https://get.foundation
// Licensed under MIT Open Source

////
/// @group functions
////

/// Adds CSS for a "quantity query" selector that automatically sizes elements based on how many there are inside a container.
/// @link http://alistapart.com/article/quantity-queries-for-css Quantity Queries for CSS
///
/// @param {Number} $max - Maximum number of items to detect. The higher this number is, the more CSS that's required to cover each number of items.
/// @param {Keyword} $elem [li] - Tag to use for sibling selectors.
@mixin auto-width($max, $elem: li) {
  @for $i from 2 through $max {
    &:nth-last-child(#{$i}):first-child,
    &:nth-last-child(#{$i}):first-child ~ #{$elem} {
      width: percentage(1 / $i);
    }
  }
}

/// Removes the focus ring around an element when a mouse input is detected.
@mixin disable-mouse-outline {
  [data-whatinput='mouse'] & {
    outline: 0;
  }
}

/// Makes an element visually hidden, but still accessible to keyboards and assistive devices.
/// @link http://snook.ca/archives/html_and_css/hiding-content-for-accessibility Hiding Content for Accessibility
/// @link http://hugogiraudel.com/2016/10/13/css-hide-and-seek/
///
/// @param {Boolean} $enforce - If `true`, use `!important` on applied properties
@mixin element-invisible(
  $enforce: true
) {
  $important: if($enforce, '!important', null);

  position: absolute #{$important};
  width: 1px #{$important};
  height: 1px #{$important};
  padding: 0 #{$important};
  overflow: hidden #{$important};
  clip: rect(0,0,0,0) #{$important};
  white-space: nowrap #{$important};
  border: 0 #{$important};
}

/// Reverses the CSS output created by the `element-invisible()` mixin.
/// @param {Boolean} $enforce - If `true`, use `!important` on applied properties
@mixin element-invisible-off(
  $enforce: true
) {
  $important: if($enforce, '!important', null);

  position: static #{$important};
  width: auto #{$important};
  height: auto #{$important};
  overflow: visible #{$important};
  clip: auto #{$important};
  white-space: normal #{$important};
}

/// Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes.
///
/// @param {Boolean} $small [true] - If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up.
/// @param {Boolean} $auto-insert-breakpoints [true] - If `false`, the mixin will iterate over breakpoints without doing the media query itself. Useful for more complex media query generation as in the margin grid.
@mixin -zf-each-breakpoint(
  $small: true,
  $auto-insert-breakpoints: true
) {
  @include -zf-each-breakpoint-in(auto, -zf-bool($small), -zf-bool($auto-insert-breakpoints)) {
    @content
  };
}

/// Iterates with `@content` through the given list of breakpoints `$breakpoints`.
///
/// @access private
///
/// @param {Keyword|List} $breakpoints [auto] - Breakpoints to iterates on. It can be a breakpoint name, list of breakpoints or `auto` for all breakpoints.
/// @param {Boolean|Null} $zero-breakpoint [null] - Whether the zero-breakpoint (often `small`) must be included. If `true`, it will always be added to the list if not already there. If `false`, it will always be removed. Does nothing by default.
/// @param {Boolean|Keyword} $media-queries [true] - Whether media-queries must be generated. If `for-lists`, only generate media-queries when `$breakpoints` is a list.
@mixin -zf-each-breakpoint-in(
  $breakpoints: auto,
  $zero-breakpoint: null,
  $media-queries: true
) {
  $-list: ();
  $-breakpoints-is-a-list: true;

  // Retrieve the list of breakpoint(s) to iterate on.
  @if $breakpoints == auto {
    $-list: $breakpoint-classes;
  }
  @else if type-of($breakpoints) == 'list' {
    $-list: $breakpoints;
  }
  @else if type-of($breakpoints) == 'string' {
    $-list: ($breakpoints);
    $-breakpoints-is-a-list: false;
  }
  @else {
    @error 'Wrong syntax for "$breakpoints" in "-zf-each-breakpoint-in()". Got "#{$breakpoints}" (#{type-of($breakpoints)}). Expected a breakpoint name, a list of breakpoints or "auto"';
  }

  // Add or remove the zero breakpoint according to `$zero-breakpoint`
  @if $zero-breakpoint == true {
    $-list: join(($-zf-zero-breakpoint), sl-remove($-list, $-zf-zero-breakpoint));
  }
  @else if $zero-breakpoint == false {
    $-list: sl-remove($-list, $-zf-zero-breakpoint);
  }

  // Iterate on breakpoint(s)
  @each $bp in $-list {
    $old-zf-size: null;
    @if global-variable-exists(-zf-size) {
      $old-zf-size: $-zf-size;
    }
    $-zf-size: $bp !global;

    @if ($media-queries == true
      or ($media-queries == 'for-lists' and $-breakpoints-is-a-list)) {
      @include breakpoint($bp) {
        @content;
      }
    }
    @else {
      @content;
    }

    $-zf-size: $old-zf-size !global;
  }
}

/// Generate the `@content` passed to the mixin with a value `$-zf-bp-value` related to a breakpoint, depending on the `$name` parameter:
/// - For a single value, `$-zf-bp-value` is this value.
/// - For a breakpoint name, `$-zf-bp-value` is the corresponding breakpoint value in `$map`.
/// - For "auto", `$-zf-bp-value` is the corresponding breakpoint value in `$map` and is passed to `@content`, which is made responsive for each breakpoint of `$map`.
/// @param {Number|Array|Keyword} $name [auto] - Single value, breakpoint name, or list of breakpoint names to use. "auto" by default.
/// @param {Number|Map} $map - Map of breakpoints and values or single value to use.
@mixin -zf-breakpoint-value(
  $name: auto,
  $map: null
) {
  @if $name == auto and type-of($map) == 'map' {
    // "auto"
    @each $k, $v in $map {
      @include breakpoint($k) {
        @include -zf-breakpoint-value($v, $map) {
          @content;
        }
      }
    }
  }
  @else {
    // breakpoint name
    @if type-of($name) == 'string' {
      $bp-value: -zf-get-bp-val($map, $name);
      @if $bp-value != null {
        $name: $bp-value;
      }
    }

    // breakpoint value
    $-zf-bp-value: $name !global;
    @content;
  }
}
